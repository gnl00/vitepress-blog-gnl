# JVM

**JDK & JRE & JVM 的区别与联系**

* JDK（Java Development Kit），Java 语言软件开发包，是整个 Java 的核心。包含 JRE 和一堆 Java 工具（javac/java/jdb 等）和 Java 基础类库（rt.java，即runtime.java）

- JRE（Java Runtime Environment），Java 运行时环境，包含 JVM 标准实现以及 Java 核心类库。JRE 是一个运行环境，不是开发环境
- JVM（Java Virtual Machine），一种用于计算机设备的规范，是一个虚拟出来的计算机，是通过在实际计算机上仿真模拟各种计算机功能来实现的

**联系**

- JVM 不能单独完成`.class`的运行。解析`.class`文件的时候 JVM 需要调用解析所需要的类库`lib`。在 JDK 目录下的 jre 目录里有两个文件夹 bin 和 lib，可以认为 bin 里就是 JVM，lib 则是 JVM 工作时所需要的类库，JVM 和 lib 合起来就成为 JRE，即`JRE=JVM+lib`
- 总的来说，开发者利用 JDK 调用 Java Api 开发出 Java 程序，通过 JDK 的编译程序`javac`将`.java`类型的 Java 文件编译成`.class`类型的 Java 字节码，之后在 JRE 上运行 Java 字节码文件，JVM 负责解析这些字节码，并映射到 CPU 指令集或 OS 进行系统调用

**区别**

- 在 JDK 的 bin 目录下有`javac.exe`，而 JRE 的 bin 目录里没有。`javac`指令是将 Java 文件编译成 Java 字节码文件的，这只是开发者需要的，运行环境 JRE 是不需要的。JDK 的 bin 目录下还有`jar.exe`和`javadoc.exe`等用于开发的可执行指令文件，这也说明 JDK 是开发环境，JRE 是运行时环境
- 仅 JVM 自身还不能执行`.class`文件，还需要 JRE 目录下 lib 类库的支持，尤其是`rt.jar`



## JVM 内存结构

> ⚠️ 需要注意内存结构和内存模型（JMM）是两个不同的概念，注意区分



**JVM 内存结构体系**

![JVM内存结构](./assets/JVM内存结构.jpg)



### 类加载子系统



#### 类加载过程

1. **加载**

   从`.class`到`Class`

   ​	a. 通过类的*全限定类名*获取定义此类的二进制字节流

   ​	b. 将这个字节流所代表的*静态存储结构*转化为方法区的*运行时数据结构*

   ​	c. 在内存中生成一个代表此类的`java.lang.Class`对象，作为方法区关于此类各种数据的访问入口

2. **连接**

   a. 验证（Verify）
   - 目的在于确保字节码文件的字节流中包含的信息符合当前虚拟机的要求。*保证被加载类的正确性*，不会危害虚拟机自身安全
   - 主要包括四种验证：文件格式验证，元数据验证，字节码验证，符号引用验证

   b. 准备（Prepare）
   - 为类变量分配内存，并且设置该类变量的默认初始值
   - 准备阶段**不包括**`final`修饰的`static`类型变量，因为`final`修饰的变量在编译时（将`.java`编译成`.class`时）就已经分配了，准备阶段会显式初始化

   c. 解析（Resolve）
   - 将常量池中的*符号引用*转换为*直接引用*的过程。符号引用就是用一组符号来描述所引用的目标，直接引用就是直接指向目标地址的指针、相对偏移量或一个间接定位到目标的语句
   - 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等

3. **初始化**

   - 初始化阶段就是执行类构造方法`<clint>()`的过程，此方法不需要定义，是`javac`编译器自动收集类中所有类变量的复制动作和静态代码块中的语句合并而来。如果类中没有定义静态变量或静态代码块，是不会有此方法的
   - 构造方法中指令按语句在源文件中出现的顺序执行
   - `<clint>()`不同于构造方法，构造方法是字节码文件中的`<lint>()`
   - 若该类具有父类，JVM保证子类`<clint>()`执行之前，父类的`<clint>()`已经执行完毕
   - JVM必须保证一个类的`<clint>()`在多线程下被同步加锁



#### 类加载器

> 类加载器（Class Loader），负责加载字节码文件，字节码文件在文件开头有特定的文件标识（CAFE BABE）。类加载器将字节码文件的内容加载到内存中，并将加载的类信息放到方法区中。类加载器只负责字节码文件的加载，至于它是否可以运行则由执行引擎（Execution Engine）决定



**类加载器分类**

1. **启动类加载器（Bootstrap ClassLoader）**
   
   - 底层代码使用C/C++实现，嵌套在JVM内部
   - 用来加载Java核心类库（`Object`、`String`、`java.lang.*`、`sun.misc.*`以及`rt.jar`、`resource.jar`和`sun.boot.class.path`路径下的内容），用于加载JVM自身需要的类
   - 启动类加载器==没有父加载器==
   - 作为==扩展类和系统类加载器的父类==加载器，==负责加载扩展类和系统类加载器==
   - 出于安全考虑，启动类加载器只加载包名为`java`、`javax`和`sun`等开头的类
2. **扩展类加载器（Extension ClassLoader）**
   
   - 由Java语言编写，实现类为`sun.misc.Launcher$ExtClassLoader`，是`sun.misc.Launcher`的匿名内部类
   - 继承自`java.lang.ClassLoader`类（ClassLoader类是一个抽象类，除了启动类加载器之外所有的类加载器都继承自ClassLoader类）
   - 父类加载器为启动类加载器
   - 负责从`java.ext.dirs`系统属性所指定的目录中加载类库，或从JDK安装目录的`jre.lib.ext`子目录下加载类库。如果用户创建的`jar`包放在此目录下，也会自动由扩展类加载器加载
3. **系统类/应用程序类加载器（System/App ClassLoader）**
   - 由Java语言编写，实现类为`sun.misc.Launcher$AppClassLoader`，是`sun.misc.Launcher`的匿名内部类
   - 继承自`java.lang.ClassLoader`类
   - 父类加载器为扩展类加载器
   - 负责加载环境变量`classpath`下或者系统属性`java.class.path`指定路径下的库
   - 是程序中默认的类加载器，一般来说Java应用的类都是由它来完成加载
   - 通过`ClassLoader.getSystemClassLoader()`可以获取到系统类加载器
4. **自定义类加载器（User-Defined ClassLoader）**

   - `java.lang.ClassLoader`的子类，用户可以定制类的加载方式，如果不是很复杂的实现类加载器，可以直接继承自`java.net.URLClassLoader`
   - 需要自定义类加载器的原因

     a. 隔离加载类

     b. 修改类的加载方式

     c. 扩展加载源

     d. 防止源码泄露



**类加载器继承关系**

<img src="./assets/image-20200430173616539.png" alt="image-20200430173616539" />





#### 双亲委派机制

> Java虚拟机对`.class`文件采用的是==按需加载==的方式，当需要使用到该类时才会将其字节码文件加载到内存中生成Class对象。而在加载某个类的字节码文件时，Java虚拟机采用的是双亲委派机制，即把请求层层交给上级处理，上级无法处理时，子类加载器才会尝试去加载，它是以一种==任务委派模式==



<img src="./assets/image-20200501160842395.png" alt="image-20200501160842395"  />



**原理**

1. 类加载器收到了类加载的请求，它不会自己先去加载，而是把这个请求向上委托给父类加载器进行加载
2. 如果父类加载器还存在父类，则进一步向上委托，最终达到最顶层的启动类加载器
3. 如果父类加载器能完成请求的类的加载任务，则由父类加载器进行加载，加载成功之后返回；若是父类加载器无法完成此加载任务（在它的加载路径下没有找到请求加载的`.class`文件），子类加载器才会尝试加载

**优点**

- 采用双亲委派机制的好处是，比如加载位于`rt.jar`包中的`java.lang.Object`类时，不管是请求哪个类加载器，都会层层向上委托到启动类加载器，使用启动类加载器进行加载。这样就保证使用不同的类加载器最终得到的都是同一个Class实例化出来的Object对象，==避免类的重复加载==
- ==防止子类加载器加载已经存在的核心类==，防止开发者代码污染Java源代码，对JVM造成破坏
- 双亲委派机制==保证JVM沙箱安全==



**沙箱安全机制**

自定义一个名为String类，定义并执行main方法，在JVM加载自定义的String类时会率先使用启动类加载器进行加载，而启动类加载器在加载过程中会先加载JDK自带的String类（`rt.jar`包中的`java.lang.String.class`）

运行自定义的String类时会报错`在类java.lang.String中找不到main方法`，原因是启动类加载器加载的是`java.lang.String`类而不是自定义的String类

这样可以保证对Java核心代码的保护，防止恶意代码污染Java源代码，这就是==沙箱安全机制==

```java
package java.lang;

/**
 * 自定义 java.lang.String
 * @author gnl
 */

public class String {
    public static void main(String[] args) {
        /**
         * 报错
         * 错误: 在类 java.lang.String 中找不到 main 方法, 请将 main 方法定义为:
         *    public static void main(String[] args)
         */
        System.out.println("this is my java.lang.String");
    }
}
```



**类加载细节**

1、JVM 中判断两个 Class 对象是否为同一个类的条件：

1）类的==全限定类名必须一致，包括包名==

2）加载这个==类的 ClassLoader 必须相同==

换言之，在 JVM 中即使两个 Class 对象来自同一个`.class`文件，被同一个虚拟机加载，只要加载它们的 ClassLoader 对象不同，这两个对象就不相等



2、JVM 必须知道一个类是由启动类还是用户自定义类加载器加载

如果一个类是由用户自定义类加载器加载，那么 JVM 就会将这个类加载器的一个引用作为类信息的一部分保存到方法区中。当解析一个类到另一个类的引用时，JVM 需要保证者两个类的类加载器是相同的



3、类的==主动使用==与==被动使用==

1）主动使用：

* 创建类实例

* 访问某个类/接口的静态变量，或是对某个类的静态变量赋值

* 调用类的静态方法

* 反射，如`Class.forName()`

* 初始化一个类的子类

* Java 虚拟机启动时被标明为启动类的类

* Java 7 开始提供的动态语言支持



2）被动使用：除了主动使用外的其他Java类的使用都可以看作是类的被动使用



### 程序计数器

-  程序计数器属于==线程私有内存==
- ==本质是一个指针==，占用一块非常小的空间，几乎可以忽略不计
-  它的作用可以看作是==当前线程所执行的字节码的行号指示器==，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的指令的字节码
- 分支、循环、跳转、异常处理、线程恢复等功能都依赖程序计数器来完成
- 不会发生内存溢出（OOM）错误
- 如果执行的是一个`Native`方法，则程序计数器为空



### 方法区

- 属于==**线程共享**的内存区域==

- 用于存储JVM加载的每个==类的结构信息、运行时常量池信息、静态变量、字符串字面量、数字常量、方法数据、构造函数、普通方法的字节码内容和即时编译器编译后的代码==等数据

- 虽然JVM规范将方法区描述为堆的一个逻辑部分，但它还有一个别名叫==非堆（Non-Heap）==，目的就是要和堆分开

- ==方法区由HotSpot独有==，J9和JRocket没有。对于HotSpot虚拟机，可以说是==使用永久代来实现方法区==，即方法区相当于一个接口，而永久代是它的实现

- ==方法区也存在垃圾回收==，但是很少，垃圾回收大多发生在堆内存

  方法区中的垃圾回收

  1. 常量池中的一些常量和符号引用若是没有被引用，则会被清理出常量池
  2. 无用的类
     - 所有实例被回收的类
     - ClassLoader被回收的类
     - 对象没有被引用的类



**方法区中的常量池**

1、类文件中常量池（The Constant Pool）

字节码文件，该文件记录了整个程序或者说当前这个类的所有相关信息，其中有一个很重要的部分被称为常量池。常量池存放编译器生成的各种字面量（Literal）和符号引用（Symbolic References）

字面量：

1）文本字符串；

2）八种基本类型的值；

3）被声明为final的常量等;

符号引用：

1）类和接口的全限定名（Fully Qualified Name）

2）字段的名称和描述符（Descriptor）

3）方法的名称和描述符



2、运行时常量池（The Run-Time Constant Pool）

相较于类文件常量池，运行时常量池更具动态性，在运行期间也可以将新的变量放入常量池中，而不是一定要在编译时确定的常量才能放入。最主要的运用便是`String.intern()`方法

位置：

1）JDK 1.6 及之前版本，它位于**方法区的永久代中**

2）JDK 1.7 逐步开始抛弃方法区，将**字符串常量池移至堆区**。这里 JDK 文档并没有说运行时常量池是否也跟着移到堆区，也就是说**运行时常量依然在方法区**，永久代仍存在于 JDK 1.7 中

3）JDK 1.8，JVM 移除了永久区，取而代之的是元空间（Metaspace），也就是将本地内存用来存储（容量取决于是32位或是64位操作系统的可用虚拟内存大小）。**字符串常量池还在堆**，运行时常量池还在方法区，只不过**方法区的实现从永久代变成了元空间。**



3、String 常量池

1）字符串常量池，即为了避免多次创建字符串对象，而将字符串在 JVM 中开辟一块空间，储存**不重复**的字符串。

2）在直接使用双引号声明字符串的时候，会先去常量池找有没有相同的字符串，如果有则将常量池的引用返回给变量。如果没有，会在字符串常量池中创建一个对象，然后返回这个对象的引用。

3）使用 new 关键字创建，比如`String a = new String("hello");`这里可能创建两个对象。一个是用双引号括起来的`hello`字符串，另一个是 new 关键字在堆中创建的新对象。最终返回的是 new 创建的对象的地址。



### 本地方法栈

- 属于==线程私有的内存区域==
- 本地方法栈与Java栈的作用类似，区别是执行Java方法使用的是Java栈，而执行Native方法时使用的是本地方法栈



### Java 栈

- 属于==线程私有的内存区域==
- 栈，又称内存，主管Java程序的运行。==线程创建时创建==，生命周期与线程相同，线程结束意味着栈内存释放。
- ==栈不存在垃圾回收的问题，线程结束即释放内存==
- Java 8 中基本类型的变量、对象的引用变量和实例方法都是在函数的栈内存中分配的
- 每个方法被执行时，都会创建一个==栈帧==，将栈帧压入栈中，当==方法正常返回或是抛出未捕获的异常==时，栈帧随之出栈



<img src="./assets/image-20210404150846257.png" alt="image-20210404150846257" style="zoom:200%;" />



**栈中的内容**

- 栈帧用于==存储局部变量表、操作数栈、动态链接、方法相关信息和方法返回值等信息==。每个方法从调用直到执行完毕的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。栈的大小和具体的JVM实现相关，通常在256k~756k之间，约等于1MB左右


- 栈中的数据都是以栈帧的格式存在，栈帧是一个内存区块，是一个数据集，是一个有关方法和运行期数据的数据集

- Java方法=栈帧
- 栈帧中主要保存3类数据
  1. 本地变量（Local Variables），输入参数和输出参数以及方法内的变量
  2. 栈操作（Operand Stack），记录出栈入栈的操作
  3. 栈帧数据（Frame Data），包括类文件、方法等



### 堆

**堆的细节**

1、属于==**线程共享**的内存区域==

2、==在JVM启动时创建==，一个 JVM 实例只存在一个堆内存（堆内存的大小可调节），此内存区域的唯一目的就是存放对象实例，==几乎所有==的对象实例都在堆中分配内存

3、类加载器读取了类文件后，将类信息、方法、常量和变量放到堆内存中，保存所有引用类型的信息，以方便执行器执行

4、根据对象生命周期的不同，JVM 会把对象进行分代管理，由垃圾回收器进行分代垃圾回收

5、当堆中没有可用空间时，会抛出 OOM 异常



#### 堆、栈和方法区的交互

<img src="./assets/image-20210406171044900.png" alt="image-20210406171044900" style="zoom:200%;" />



#### 堆内存对象分配逻辑

堆内存**物理上**只存在两个部分：新生区和养老区

堆内存**逻辑上**分为三部分：新生代、养老带、永久代（Java7）/元空间（Java8）

**Java7和Java8区别**

**Java7**

![image-20210404162929943](./assets/image-20210404162929943.png)

1、Young/New Generation Space，新生区

2、Tenure/Old Generation Space，养老区

3、Permanent/Perm Space，永久区

- 永久区是一个常驻内存的区域，用于存放JDK自身所携带的类和接口元数据
- ==存储的是运行环境必须的类信息，被装载进入此区域的数据是不会被垃圾回收的，关闭JVM才会释放此区域所占用的内存==



**Java8**

![image-20210404163110189](./assets/image-20210404163110189.png)

**1、新生代**

- 新生区是类创建、应用、消亡的区域。一个类在新生区创建，应用，最后被垃圾回收器收集，将其回收

- 新生区又分为两部分

  1）伊甸区（Eden Space）

  - 几乎所有的类（大对象直接在老年代创建）都是在伊甸区被创建出来
  - 对象被创建的时候首先放到伊甸区域，新生代分配不了的内存大的对象会直接进入老年代
  - 在第一次 GC 开始前，对象只会存在于 Eden 区和 From 区，To 区是空的
  - 当伊甸区空间用完时，程序又需要创建对象，JVM 的垃圾回收器就会对伊甸区进行垃圾回收（Minor GC）。**只要产生 GC，伊甸区几乎会被全部清空，剩余的对象转移到幸存者To区**

  2）幸存者区（Survivor Space），幸存者区分为：0区（Survivor 0 Space）和1区（Survivor 1 Space）

  - 幸存者0区和1区又叫 From 区和 To 区，From 和 To 不是固定的，每次 GC 后 From 和 To 会交换，GC 后为空的就是 To 区
  - 当幸存者区中 From 和 To 来回复制交换次数达到15次（次数由 JVM 参数`MaxTenuringThreshold`决定，默认为15）之后，还存活的对象就存入养老区

- 新生区GC（Young GC），对新生区包括伊甸和幸存者区进行垃圾回收

- **新生区的内存区域小于养老区，占堆内存的1/3，对象存活率低，因此 GC 适合使用复制算法**

**2、养老区**

- 养老区内存空间满了之后开启 GC（Full GC，又称 Major GC，==FGC会清理整个堆空间==，包括新生代和老年代），**FGC 多次后若养老区空间依然是满的则会报 OOM 异常`java.lang.OutOfMemoryError:Java heap space`**

  1）产生 OOM 异常原因

  * Java虚拟机的堆内存设置不够，可通过参数`-Xms`和`-Xmx`来调整

  * 代码中创建了大量对象，并且长时间不能被垃圾回收器收集（仍被引用）

  2）**养老区内存区域相对较大，占堆空间的2/3，对象存活率高，因此GC算法常用标记清除或标记清除和标记整理的混合实现**

**3、Meta Space 元空间**

- 元空间的本质和永久代类似，存放类的元数据

  1）永久代使用的是 JVM 的堆内存，但 **Java 8 的元空间并不在虚拟机堆内存中，而是在本机的物理内存**

  2）默认情况下，元空间的大小受本地内存限制，类的元数据放入本地物理内存中，此时可以加载多少类的元数据不再由`MaxPermSize`控制，而是由本地内存的实际可用空间来控制

![image-20210404164924346](./assets/image-20210404164924346.png)

**堆参数调整**

- -Xmx，设置初始分配大小，默认为物理内存的1/64
- -Xms，最大分配内存，默认为物理内存的1/4
- -XX:MaxTenuringThreshold，设置对象在新生代中交换的次数
- -XX:+PrintGCDetails，输出详细的GC处理日志



#### 并发场景堆内存分配

> 在并发场景中，如何保证内存分配过程的线程安全性？如果两个线程先后把对象引用指向了同一个内存区域，怎么办？

1、==对分配内存空间的动作做**同步处理**，采用**CAS机制**，配合失败重试的方式保证更新操作的线程安全性==

缺点：在每次分配时都需要进行同步控制，效率较低

2、每个线程在Java堆中预先分配一小块==“私有”内存==，在给对象分配内存时，直接在这块内存中分配。当这部分区域用完之后，再分配新的“私有”内存

- HotSpot虚拟机中采用的方式，被称为**TLAB分配**（Thread Local Allocation Buffer），这部分Buffer是从堆中划分出来的，但是是**本地线程独享**的。需要注意的是，==虽然说TLAB是线程独享的，但是只是在“分配”这个动作上是线程独占的。至于在读取、垃圾回收等动作上都是线程共享的，而且在使用上也没有什么区别==

- ==TLAB仅作用于新生代的Eden Space==

- 使用TLAB之后，在TLAB上给对象分配内存时线程独享，并发场景下的冲突得到解决，但是TLAB这块内存自身从堆中划分出来的过程也可能存在内存安全问题，所以在对于TLAB的分配过程，还是需要进行同步控制的，但是这种开销相比于每次为单个对象划分内存时候对进行同步控制的要低得多

- 虚拟机是否使用TLAB是可以选择的，可以通过`-XX:+/-UseTLAB`参数来设置

- TLAB是线程特有的，它的内存区域不是很大，所以会出现一些不够用的情况，此时则无法直接在TLAB上分配了，这种情况有两种解决办法

  1. 直接在堆中分配

     缺点就是存在一种极端情况，TLAB只剩下1KB，就会导致后续的分配可能大多数对象都需要直接在堆中分配

  2. 废弃当前TLAB，重新申请TLAB空间再次进行内存分配

     会出现频繁的废弃TLAB、频繁申请TLAB的情况

  

  为了解决这两个方案存在的问题，虚拟机定义了一个`refill_waste`的值，这个值可以看成**最大浪费空间**
  
  当请求分配的内存大于refill_waste的时候，会选择在堆内存中分配。若小于refill_waste值，则会废弃当前TLAB，重新创建TLAB进行对象内存分配





## 垃圾回收



### 垃圾回收算法



#### 强/软/弱/虚引用

1、**强引用**，强引用即为平常使用得最多的引用，强引用的对象即便在程序内存不足（OOM）的时候也不会被回收

2、**软引用**，软引用的对象在程序内存不足时，会被回收

3、**弱引用**，弱引用的对象，只要 JVM 的垃圾回收器发现了它，就会被回收

4、**虚引用**，虚引用的回收机制和弱引用一致，但它在被回收之前，会被放入回收队列`ReferenceQueue`中。其他几种引用是被 JVM 的垃圾回收机制**回收之后**，才传入`RefernceQueue`中。虚引用大多被用于引用销毁前的处理工作，因此，虚引用创建的时候必须带有`RefernceQueue`参数



**GC是什么**

GC（Garbage Collector），垃圾收集器



**GC日志信息**

<img src="./assets/image-20210406150611786.png" alt="image-20210406150611786" style="zoom:200%;" />



**总体概述**

<img src="./assets/image-20210406151057954.png" alt="image-20210406151057954" style="zoom:200%;" />



**GC算法**

==分代垃圾收集算法==（没有最好的算法，只有根据堆中不同代使用的不同算法）

**判断对象是否可以被回收**

1. **引用计数法**

   - 在Java中，引用和对象是有关联的。如果要操作对象则必须使用对象的引用进行操作。因此可以通过对象的引用次数来判断一个对象是否可以被回收

   - 操作如下，给对象中添加一个引用计数器，每当有一个地方引用它，计数器值加1；每当有一个引用失效时，计数器值减1。任意时刻计数器值为0的对象就是不可能再被使用的，那么此对象就是可回收对象

   - 缺点

     1. 每次对象赋值时都要维护引用计数器，而且计数器本身也有一定的消耗
     2. 较难处理循环引用

   - ==JVM一般不采用此方法，其中最主要的原因是它很难解决对象之间相互循环引用的问题==

     假设对象A和B相互引用，此外没有其他引用指向A和B。这种情况下，若A和B已不再被使用，但由于它们的引用计数器都不为0，在使用引用计数法时，就会将这两个对象判断为不可被回收。这种情况下就可能造成内存泄漏

2. **可达性分析**

   - GC Roots，特指垃圾收集器对象，垃圾回收过程中会回收不是GC Roots，且没有被GC Roots引用的对象
   - 通常有以下对象会被认为是Root对象
     1. 虚拟机栈中引用的对象（栈帧中的本地变量表）
     2. 方法区中静态属性引用的对象
     3. 方法区中常量引用的对象
     4. 本地方法栈中Native方法引用的对象
   - 通过一系列`GC Roots`对象作为起点进行遍历，==如果在GC Roots和某个对象之间没有可达路径，则表示该对象是不可达的==
   - 不可达的对象不一定会成为可回收对象
     1. 可能是进入`DEAD`状态的线程，而进入`DEAD`状态的线程是可以恢复的，因此GC不会回收它的内存
     2. 不可达对象为Root对象，JVM认为Root对象是不可回收的，并且Root引用的对象也是不可回收的


**垃圾回收**

1. **复制算法**（Copying），新生代

   - 新生代发生Young GC时，使用的就是复制算法。==因为新生代中的对象一般存活率不高，来回复制开销小，所以在新生代使用复制算法==

   - 复制算法将内存分为两块，每次只用其中一块，当一块用完，就将还活着的对象复制到另一块内存上

   - 因为新生代对象一般存货率较低，所以通常使用两块10%的内存作为空闲和活动空间，即From和To。而另外80%的内存则用来给新建对象分配内存，即Eden区。一旦发生GC，将10%的From区中存活的对象与另外80%的Eden区中存活的对象复制到10%的To空闲区，接下来将Eden和From这90%的内存全部释放

   - 优点：不会产生内存碎片

   - 缺点：消耗内存，可用内存减少，当有大量对象存活时，会产生较大复制开销


   ![image-20210406162509076](./assets/image-20210406162509076.png)

2. **标记清除算法**（Mark-Sweep），老年代

   - 老年代的GC算法一般是由标记清除或标记清除和标记整理混合实现

   - ==标记清除算法分为标记和清除两个阶段，先标记（Marking）出要回收的对象，然后再统一回收/清除（Sweep）这些对象==

   - 程序在运行期间，若可以使用的内存被耗尽，GC线程就会被触发，并将程序暂停。随后将要回收的对象标记，最终统一回收被标记的对象，完成标记清除工作后让应用程序恢复运行

   - 优点：不需消耗额外空间

   - 缺点：

     1. 标记和清除分两次扫描，耗时严重，效率较低
     2. 会产生内存碎片，为了解决这个这个缺点，JVM需要维持一个内存的空闲列表，产生额外开销。而且在分配数组对象时，寻找连续的内存空间会不太好找

   - 回收前

   <img src="./assets/image-20210406163014653.png" alt="image-20210406163014653" style="zoom:200%;" />

   - 回收后

     <img src="./assets/image-20210406163235444.png" alt="image-20210406163235444" style="zoom:200%;" />

3. **标记压缩**（Mark-Compact）/标记整理，老年代

   - 标记压缩=标记清除+标记整理，经过多次标记清除GC后，才会进行Compact压缩

   - 在标记整理的压缩阶段，不是标记回收对象，而是==标记存活对象，标记完成后把所有的存活对象都向一端移动，然后直接清除存活边界外的内存==。标记存活的对象就得到了整理，按照内存地址依次排序，未被标记的内存就会被清理。在之后给新对象分配内存时，JVM只需要持有空闲内存起始地址即可，比标记清除维护的空闲列表开销显然少了许多

   - 优点：没有内存碎片，可以利用bump

   - 缺点：需要付出移动对象的成本，相比于前几个算法耗时长


   ![image-20210406165228525](./assets/image-20210406165228525.png)



**GC算法比较**

- 效率

  复制 ==> 标记清除 ==> 标记整理

- 内存整齐度

  复制 = 标记整理 ==> 标记清除

- 内存利用率

  标记整理 = 标记清除 ==> 复制



**GC算法的使用**

- 新生代内存区域相对养老区小，占堆空间的1/3，对象存活率低，因此GC适合使用复制算法
- 老年代内存区域相对较大，占堆空间的2/3，对象存活率高，因此GC算法通常用标记清除或标记压缩



**垃圾回收过程**

对象被判定是否可回收，需要经历两个阶段

1. 可达性分析
2. 查看需要回收的对象是否重写了`finalize()`方法或者该对象的`finalize()`方法是否已被调用过
   - `finalize()`方法的作用是给该对象一次救活的机会
   - GC 要回收一个对象时，不会直接将其回收，而是调用一次该对象的`finalize()`方法，在下次垃圾回收的时候，才会回收这个对象
   - 可以在`finalize()`方法中定义一些对象在释放前必须执行的操作





### 垃圾收集器



#### CMS

> CMS（Concurrent Mark Sweep）收集器，CMS 收集器是**获取最短回收停顿时间为目标**的收集器，**使用的标记清除算法**



**<u>1 - CMS 垃圾回收过程</u>**

1、初始标记（CMS initial mark)）

2、并发标记（CMS concurrent mark）

3、重新标记（CMS remark）

4、并发清除（CMS concurrent sweep）



其中初始标记和重新标记会停止所有的用户线程。并发标记阶段就是进行 GC Roots Tracing 的过程。

重新标记是为了修正并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般比初始标记阶段长。

整个 GC 过程当中消耗时间最长的是并发标记和并发清除过程，但是这两个阶段的垃圾回收线程可以与用户线程一起并发执行。总体上说 CMS 收集器的内存回收过程是与用户线程一起并发执行的。



**<u>2 - CMS 优缺点</u>**

**缺点**

- CMS 对 CPU 资源敏感,在并发阶段虽然不会停止用户线程,但是会占用一部分线程来进行垃圾回收,总吞吐量会降低。
- CMS 默认启动的线程是(CPU数量+3)/4,当 CPU 大于4个以上占用资源不超过 25% 的 CPU 资源,但是小于 4 个 CPU 时候 CMS 收集器对用户程序的影响就比较大。
-  CMS 无法回收浮动垃圾。CMS 在并发清理阶段还可以运行用户线程,这时候还会产生新的垃圾,而这部分垃圾 CMS 无法在本次回收掉,这部分就是浮动垃圾。因此 CMS 不能像其他的收集器等到年老代几乎全部满了再进行回收,需要预留一部分空间提供并发收集时候的用户线程使用。默认设置下,CMS 收集器在年老代使用了 68% 的空间后就会被激活,可以通过 -XX:CMSInitiatingOccupancyFraction 参数来设置这个属性。如果 CMS 在运行时候预留的内存无法满足程序需要,就会出现一次“Concurrent Mode Failure”失败,这时候虚拟机临时启用 Serial Old 收集器重新来进行老年代的垃圾收集。
- CMS 是基于标记清除算法,在清理的过程中会有大量的空间碎片。空间碎片过多后给打对象分配空间会有很多麻烦。CMS 提供了一个参数 -XX:+UseCMSCompactAtFullCollection 用来在 Full GC 完成后附加一个碎片整理过程,碎片整理无法并发会导致停顿时间变长。当然还提供了一个参数 -XX:CMSFullGCsBeforeCompaction,这个参数设置在执行多少次不压缩的 Full GC 后,跟着来一次带压缩的。



**<u>3 - CMS 发生 Full GC 原因分析</u>**

1）堆中分配很大的对象

所谓大对象，是指需要大量连续内存空间的 Java 对象，例如很长的数组，此种对象会直接进入老年代，而老年代虽然有很大的剩余空间，但是无法找到足够大的连续空间来分配给当前对象，此种情况就会触发 JVM 进行 Full GC。

为了解决这个问题，CMS 垃圾收集器提供了一个可配置的参数，即`-XX:+UseCMSCompactAtFullCollection`开关参数，用于在“享受”完 Full GC 服务之后额外免费赠送一个碎片整理的过程，内存整理的过程无法并发的，空间碎片问题没有了，但提顿时间不得不变长了，JVM 设计者们还提供了另外一个参数：`XX:CMSFullGCsBeforeCompaction`，这个参数用于设置在执行多少次不压缩的 Full GC后，跟着来一次带压缩的



2）`System.gc()`方法的调用

3）老年代空间不足

老年代空间只有在新生代对象转入及创建为大对象、大数组时才会出现不足的现象，当执行 Full GC 后空间仍然不足，则抛出错误：`java.lang.OutOfMemoryError: Java heap space`

为避免以上两种状况引起的 Full GC，调优时应尽量做到让对象在 Minor GC 阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组



4）方法区空间不足

Permanet Generation 中存放的为一些 class 的信息、常量、静态变量等数据。当系统中要加载的类、反射的类和调用的方法较多时，Permanet Generation 可能会被占满，在未配置采用 CMS GC 的情况下会执行 Full GC。如果经过Full GC仍然回收不了，那么 JVM 会抛出错误信息：`java.lang.OutOfMemoryError: PermGen space`。为避免 Perm Gen 占满造成 Full GC 现象，可采用的方法为增大 Perm Gen 空间或转为使用 CMS GC



5）CMS GC 时出现 promotion failed 和 concurrent mode failure

对于采用 CMS 进行老年代 GC，要注意 GC 日志中是否有 promotion failed 和 concurrent mode failure 两种状况，当这两种状况出现时可能会触发Full GC。

promotion failed 是在进行 Minor GC 时，survivor space 放不下、对象只能放入老年代，而此时老年代也放不下造成的；

concurrent mode failure 是在执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足造成的（有时候“空间不足”是使用 CMS GC 时当前的浮动垃圾过多导致暂时性的空间不足触发 Full GC）。

解决措施为：增大 survivor space、老年代空间或调低触发并发 GC 的比率，但在 JDK 5.0+、6.0+ 的版本中有可能会由于 JDK 的 bug29 导致 CMS 在 remark 完毕后很久才触发 sweeping 动作。对于这种状况，可通过设置`-XX: CMSMaxAbortablePrecleanTime=5（单位为ms）`来避免



6）Minor GC 晋升到老年代的平均大小大于老年代的剩余空间

Hotspot 为了避免由于新生代对象晋升到旧生代导致旧生代空间不足的现象，在进行 Minor GC 时，做了一个判断，如果之前统计所得到的 Minor GC 晋升到旧生代的平均大小大于旧生代的剩余空间，那么就直接触发 Full GC。

例如程序第一次触发 Minor GC 后，有 6MB 的对象晋升到旧生代，那么当下一次 Minor GC 发生时，首先检查老年代的剩余空间是否大于6MB，如果小于6MB，则执行Full GC。

当新生代采用 PS GC 时，方式稍有不同，PS GC 是在 Minor GC 后也会检查，例如上面的例子中第一次 Minor GC 后，PS GC 会检查此时旧生代的剩余空间是否大于6MB，如小于，则触发对旧生代的回收。







#### G1

> G1 是一款面向服务端应用的垃圾收集器



**<u>1 - G1 垃圾回收过程</u>**

1、初始标记；

2、并发标记；

3、最终标记；

4、筛选回收

上面几个步骤的运作过程和CMS有很多相似之处。

初始标记阶段仅仅只是标记一下 GC Roots 能直接关联到的对象，并且修改TAMS的值，让下一个阶段用户程序并发运行时，能在正确可用的 Region 中创建新对象，这一阶段需要停顿线程，但是耗时很短。

并发标记阶段是从GC Root开始对堆中对象进行可达性分析，找出存活的对象，这阶段时耗时较长，但可与用户程序并发执行。

而最终标记阶段则是为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remenbered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这一阶段需要停顿线程，但是可并行执行。

最后在筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。



**<u>2 - G1 优缺点</u>**

**1、优点**

1）并行于并发：G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。

2）分代收集：虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。它能够采用不同的方式去处理新创建的对象和已经存活了一段时间，熬过多次GC的旧对象以获取更好的收集效果。

3）空间整合：与CMS的“标记清理”算法不同，G1从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。

4）可预测的停顿：这是G1相对于CMS的另一个大优势，降低停顿时间是G1和ＣＭＳ共同的关注点，但Ｇ１除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，





> 关于JVM的内容暂且告一段落啦...















## 参考

[Java字符串常量池，运行时常量池，jdk1.7后intern方法的变化_zzzgd_666的博客-CSDN博客](https://blog.csdn.net/zzzgd_666/article/details/87999870)

[JVM之G1和CMS_zsj777的专栏-CSDN博客](https://blog.csdn.net/zsj777/article/details/80353464)

[CMS发生FullGc分析_春哥大魔王的博客-CSDN博客](https://blog.csdn.net/peter7_zhang/article/details/107011297)