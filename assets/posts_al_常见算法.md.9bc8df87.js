import{_ as a,o as e,c as l,Q as i}from"./chunks/framework.834b76fb.js";const u=JSON.parse('{"title":"常见算法","description":"","frontmatter":{},"headers":[],"relativePath":"posts/al/常见算法.md","filePath":"posts/al/常见算法.md"}'),r={name:"posts/al/常见算法.md"},t=i('<h1 id="常见算法" tabindex="-1">常见算法 <a class="header-anchor" href="#常见算法" aria-label="Permalink to &quot;常见算法&quot;">​</a></h1><br><h2 id="分治" tabindex="-1">分治 <a class="header-anchor" href="#分治" aria-label="Permalink to &quot;分治&quot;">​</a></h2><p>将一个复杂的问题分解成 n 个小问题，并且要求小问题的解法和大问题的解法一致，从而将大问题分而治之。分治是思想，递归是手段，分治和递归经常放在一起使用。</p><p>如果一个复杂问题具有以下几个特征：</p><ol><li>该问题缩小到一定规模后就可以很容易解决；</li><li>该问题可以分解成若干个解法一致的小问题；</li><li>该问题的结果可以由若干个小问题的结果合并而成；</li><li>若干个小问题之间相互独立，任意子问题之间没有交集解；</li></ol><p>第一个特征几乎所有的复杂问题都符合；第二个特征也是几乎所有的问题都符合，它是分治法中运用递归手段的前提；第三个特征是关键，能否利用分治法取决于第三个特征，如果具备一和二，不具备三，可以考虑使用动态规划或者贪心算法；第四个特征涉及到分治法的效率问题，如果子问题之间不相互独立，分治法还需要处理重复解，多做了一部分工作。此时虽然可以用分治法，但还是使用动态规划比较好。</p><p>使用步骤：</p><ol><li>将复杂问题分解成具有相同解法的小问题</li><li>若小问题规模足够小，直接解决，否则递归解决各个小问题；</li><li>合并各个子问题的解。</li></ol><br><h2 id="动态规划" tabindex="-1">动态规划 <a class="header-anchor" href="#动态规划" aria-label="Permalink to &quot;动态规划&quot;">​</a></h2><p>将复杂问题分解成若干小问题，按顺序逐一求解。处理问题时将满足条件的解保存，前驱问题的解能为后续问题的解提供有用信息，然后重复上述步骤，直到求出所有可能的解。最后在局部解中找到最优解。</p><p>与分治法最大的区别是，动态规划下一个子问题的解是建立在上一个子问题的解的基础上，进一步求解得到的。</p><p>如果一个问题具有以下特征：</p><ol><li>求最优化解；</li><li>前驱子问题解确定之后不受后续子问题解的干扰；</li><li>子问题之间不相互独立，后续子问题的解依赖前驱子问题的解。</li></ol><p>使用步骤：</p><ol><li>划分阶段，将问题按照一定维度进行拆分，划分后的各个子问题必须是有序或可排序的；</li><li>确定状态，将各个前驱问题的解通过一定状态表示出来，并将其保存；</li><li>确定决策和状态转移方程，转移状态就是根据前驱问题的状态通过决策求出现阶段的解，如果确定了决策状态转移方程就可以很快写出。通常的做法是根据相邻状态之间的关系来确定决策方法和转移方程；</li><li>寻找边界条件，状态转移方程是一个递推式，需要一个递归的终止条件。</li></ol><br><h2 id="贪心" tabindex="-1">贪心 <a class="header-anchor" href="#贪心" aria-label="Permalink to &quot;贪心&quot;">​</a></h2><br><h2 id="回溯" tabindex="-1">回溯 <a class="header-anchor" href="#回溯" aria-label="Permalink to &quot;回溯&quot;">​</a></h2><br><h2 id="分支界限" tabindex="-1">分支界限 <a class="header-anchor" href="#分支界限" aria-label="Permalink to &quot;分支界限&quot;">​</a></h2><br><h2 id="kmp" tabindex="-1">KMP <a class="header-anchor" href="#kmp" aria-label="Permalink to &quot;KMP&quot;">​</a></h2><p><a href="https://www.zhihu.com/question/21923021/answer/281346746" target="_blank" rel="noreferrer">如何更好地理解和掌握 KMP 算法?</a></p>',26),o=[t];function h(n,s,p,c,d,_){return e(),l("div",null,o)}const m=a(r,[["render",h]]);export{u as __pageData,m as default};
